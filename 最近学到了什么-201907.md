---
title: "最近学到了什么-201907"
date: "2019-07-31"
tags: ["Linux内核","netfilter"]
toc: "true"
categories: ["学习笔记"]
---

本文主要记录对于连接跟踪以及其主要应用的NAT和状态iptables的学习内容

###  分支预测likely和unlikely
likely() 与 unlikely()是Linux内核中定义的两个宏。位于/include/linux/compiler.h中。使用在if语句的判断中，类似于
``` c
if (likely(条件A)) {
    do A;
} 
else {
    do B;
}
```
其大概作用是，让开发者来提前告诉编译器这个条件是更大概率发生的（likely）或者更大概率不会发生的（unlikely）。使用likely ，执行if后面语句的可能性大些，编译器将if{}中的内容编译到前面, 使用unlikely ，执行else后面语句的可能性大些,编译器将else{}里的内容编译到前面。这样有利于cpu预取,提高预取指令的正确率,因而可提高效率

### Linux内核参数传递
module_param()宏是Linux 2.6内核中新增的，该宏被定义在include/linux/moduleparam.h文件中
这个宏定义应当放在任何函数之外, 典型地是出现在源文件的前面.定义如
``` c 
static int howmany = 1;
module_param (howmany, int, S_IRUGO);
/*使用 S_IRUGO 作为参数可以被所有人读取*/
```
模块被加载后，在/sys/module/ 目录下将出现以此模块名命名的目录，在其中parameters目录下就可以看到参数对应的文件，直接echo即可向内核传递参数

### 哈希表和二叉查找树的选取
哈希表是一种线性结构，通过对key值合理hash，理论上插入与查询操作都可以做到O(1)复杂度。由于哈希表可能会存在冲突，在处理哈希冲突时，无论是线性探测还是开放寻址，都能达到O(n)的复杂度，且如果哈希表不够存储当前数据，可能需要扩充哈希表，很可能需要重新计算哈希
二叉查找树我们一般讨论自平衡二叉查找树，像红黑树、AVL树。对于n个节点的树，插入与查询的时间复杂度都在O(logn)
**因此选择的关键点在于数据的性质与大小，如果数据不易产生哈希冲突、数据量已知可控那么就可选择哈希表，如果数据是未知不可控的，就最好选择二叉查找树**

### Linux内核、驱动编码限制

类似于fopen，fwrite，fread这类函数都是为用户空间程序提供的，我们的驱动程序运行在内核空间，无法调用这些函数，因此需要调用更底层的系统调用函数进行某些操作。同理，在用户空间编写的动态链接库等也是无法在内核中使用的，很多造好的轮子是没法在内核编码中引用的

### 结构体对齐
我们都知道结构体在存储时会进行内存对齐，简单来讲就是对存储空间和读取速度的取舍：对齐粒度越小，浪费的内存空洞就越少，约节省内存空间。对齐粒度越接近CPU的位数，读取效率越高，32位CPU一次能读取32个二进制位内存，也就是4字节，那么四字节对齐时CPU读取效率就最高
相关规则：



- 成员变量的地址要对齐到对齐数的整数倍的地址处
- 对齐数=对齐系数 与 该成员大小的较小值
- linux中默认为4字节对齐，vs中默认为8
- 结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）
- 结构体的对齐数是自己内部成员的对齐数中的最大对齐数

### git log显示优化
git log显示commit日志时，默认是分页显示的，而且内容很多，有时候我们往往不需要那么多内容，其实可以精简一下

``` bash
git --no-pager log -1 --pretty=format:"%ad" --date=short -C /home/target
# --no-pager 指定不分页
# -1 指定显示最近一次commit
# -C 指定某个目录或者文件显示log
#--pretty=可以美化输出，具体参数可以进一步查询
```
### 0.0.0.0 网络地址

根据RFC文档描述，它不只是代表本机，**0.0.0.0/8可以表示本网络中的所有主机，0.0.0.0/32可以用作本机的源地址，0.0.0.0/8也可表示本网络上的某个特定主机,综合起来可以说0.0.0.0表示整个网络**。它的作用是帮助路由器发送路由表中无法查询的包。如果设置了全零网络的路由，路由表中无法查询的包都将送到全零网络的路由中去，也就是默认网关。严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有未知的主机和目的网络。这里的“未知”是指在本机的路由表里没有特定条目指明如何到达

### 16位压缩MD5与32位可读MD5

MD5值可以用16位十进制int存储，也可用可读的32位16进制字符存储，他们之间可以互相转化
``` c
// 16进制字符转10进制
inline int hexToDec(char c) {
    int n;
    if (c >= '0' && c <= '9') {
        n = c - '0';
    } else {
        n = c - 'a' + 10;
    }

    return n;
}

// 一个char中有2个16进制，转为2个10进制字符
inline void intDecToHex(unsigned char n, char* buf) {
    int t = 0;
    char c;
    t = n & 0x0f;
    if (t >=0 && t <= 9) {
        c = t + '0';
    } else {
        c = t - 10 + 'a';
    }
    buf[1] = c;

    n = n >> 4;
    t = n & 0x0f;
    if (t >=0 && t <= 9) {
        c = t + '0';
    } else {
        c = t - 10 + 'a';
    }
    buf[0] = c;
}

// 压缩md5 32为 转为16位
void encode32To16(const char* ori_str, unsigned char* out) {
    short index = 0;
    unsigned char tm;
    for (int i = 0; i < 32; ++index) {
        tm = 0;
        short n = hexToDec(ori_str[i++]);
        tm |= n;
        tm = tm << 4;
        n = hexToDec(ori_str[i++]);
        tm |= n;
        out[index] = tm;
    }
    return;
}

// 16位压缩md5转为32位
void decode16To32(unsigned char* ori_str, char* out) {
    short index = 0;
    char buf[2] = {0};
    unsigned char tm;
    int index_ = 0;
    for (int i = 0; i < 16; ++i) {
        intDecToHex(ori_str[i], buf);
        out[index++] = buf[0];
        out[index++] = buf[1];
        index_ ++;
    }
    return;
}
作者：adfa 
来源：CSDN 
原文：https://blog.csdn.net/qiuchang008/article/details/80012994 
版权声明：本文为博主原创文章，转载请附上博文链接！
```

###  Linux中的hook函数

在Linux中处理网络数据包经常需要使用到hook钩子，其实就是类似于一种触发点的机制

**hook函数依赖的结构体**
``` c
struct nf_hook_ops
{
        struct list_head list;           //链表成员      
        /* 下面这些需要函数编写者填入 */
        nf_hookfn *hook;              //钩子函数指针     
        struct net_device    *dev; /* 设备 */
        int pf;                            //协议簇protocol flags，对于ipv4而言，是PF_INET
        int hooknum;                   //hook类型       
        int priority;                     //优先级};
```

其中：
**hook**为用户定义的钩子函数，原型为：
``` c
typedef unsigned int nf_hookfn(void *priv,
                   struct sk_buff *skb,
                   const struct nf_hook_state *state);
```
nf_hookfn执行后需要返回以下返回值：  
NF_ACCEPT：  继续正常的报文处理；  
NF_DROP：      将报文丢弃；  
NF_STOLEN：  由钩子函数处理了该报文，不要再继续传送；  
NF_QUEUE：    将报文入队，通常交由用户程序处理；  
NF_REPEAT：   再次调用该钩子函数。  
**dev**为网络设备  
**pf**是协议簇protocol flags，对于ipv4而言，是PF_INET，可选值有  

``` c
enum {
    NFPROTO_UNSPEC =  0,
    NFPROTO_INET   =  1,
    NFPROTO_IPV4   =  2,
    NFPROTO_ARP    =  3,
    NFPROTO_NETDEV =  5,
    NFPROTO_BRIDGE =  7,
    NFPROTO_IPV6   = 10,
    NFPROTO_DECNET = 12,
    NFPROTO_NUMPROTO,
};
```
**hooknum**为hook点，可选值有以下几种，对应Linux的netfilter的hook点
``` c
enum nf_inet_hooks {
    NF_INET_PRE_ROUTING,
    NF_INET_LOCAL_IN,
    NF_INET_FORWARD,
    NF_INET_LOCAL_OUT,
    NF_INET_POST_ROUTING,
    NF_INET_NUMHOOKS
};
```
最后一个参数**priority**为hook优先级，内核定义了以下多种优先级:
``` c
enum nf_ip_hook_priorities       //include/linux/netfilter_ipv4.h
{
　　NF_IP_PRI_FIRST = INT_MIN,
　　NF_IP_PRI_CONNTRACK = -200,
　　NF_IP_PRI_MANGLE = -150,
　　NF_IP_PRI_NAT_DST = -100,
　　NF_IP_PRI_FILTER = 0,
　　NF_IP_PRI_NAT_SRC = 100,
　　NF_IP_PRI_LAST = INT_MAX,
};
```

