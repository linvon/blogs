---
title: "柔性数组与结构体的使用"
date: "2018-12-04"
tags: ["C","柔性数组","结构体"]
categories: ["学习笔记", "C"]
---
在日常编程中，有时会遇到需要在结构体中定义动态长度的结构体成员。此时便需要使用到柔性数组。

# **什么是柔性数组**

柔性数组是C99的一个扩展，简而言之就是一个在struct结构体里的标识占位符（不占结构struct的空间）。

结构体中的最后一个元素允许是未知大小的数组，叫做柔性数组(flexible array)成员，但结构体中的柔性数组成员前面必须至少有一个其他成员。

柔性数组成员不仅可以用于字符数组，还可以是元素为其它类型的数组。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

```c++
typedef struct st_type
{
    int i;
    int a[0];
} type_a;

//部分编译器不支持上述写法，可以使用以下写法定义
typedef struct st_type
{
    int i;
    int a[];
} type_a;

printf("%d",sizeof(type_a)); //4 
//柔性数组不会占用struct结构体的空间
```

## **柔性数组的使用**

```c++
int i = 0;
int cnt = 100;
type_a *p = (type_a *)malloc(sizeof(type_a)+ cnt * sizeof(int));
p->i = 100;
for(i=0;i<cnt;i++)
{
	p->a[i]=i;
}
free(p); //记得释放分配的空间
```

## **写法优势**

> 第一个好处是：方便内存释放
>
> 如果我们的代码是在一个给别人用的函数中，你在函数中做了两次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。 
>
> 第二个好处是：有利于提高访问速度
>
> 连续的内存有益于提高访问速度，也有益于减少内存碎片。
>
> 
>
> 作者：lws123253 
> 来源：CSDN 
> 原文：https://blog.csdn.net/lws123253/article/details/80293743 

# **结构体的赋值与拷贝**

```c++
struct A {
    int b;
    int c;
}

//定义时初始化
struct A a = {
    .b = 1,
    .c = 2
};

struct A a={
    b:1,
    c:2
}；

struct A a1 = {1, 2};

//使用构造函数初始化
struct A {
    A(int a,int b){
        this->a=a;
        this->b=b;
    };
    int b;
    int c;
}
struct A a(1,2);

//定义后置空
struct A a = {0};
//或者（常用）按照编译器默认的方式进行初始化（如果a是全局静态存储区的变量，默认初始化为0，如果是栈上的局部变量，默认初始化为随机值）
struct A a; 
memset(&a,0,sizeof(a));

//考虑到结构体中经常包含字符串指针等指针形变量，结构体之间的赋值拷贝一般采用内存拷贝
memcpy(&dstStu, &srcStu, sizeof(Stu));

```