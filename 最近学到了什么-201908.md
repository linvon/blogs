---
title: "\u6700\u8FD1\u5B66\u5230\u4E86\u4EC0\u4E48-201908"
date: "2019-09-02"
toc: true
tags: ~
categories:
- "\u5B66\u4E60\u7B14\u8BB0"
...
--- 
### 将Grep结果合并为一行

``` bash
cat test | grep abc | xargs | tr ' ' ','
```

### 使用Shell脚本非交互式修改Linux用户密码

``` bash
两种方式
echo "password" | passwd testuser --stdin > /dev/null 2>&1
或
echo testuser:password | chpasswd
```

### Linux下/etc/passwd和/etc/shadow的区别

/etc/passwd是用户数据库，其中的域给出了用户名、加密口令和用户的其他信息.
/etc/shadow是在安装了影子(shadow)口令软件的系统上的影子口令文件。
影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对超级用户root可读。这使破译口令更困难，以此增加系统的安全性。 
版权声明：本文为CSDN博主「Vincent_江」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_36747237/article/details/80447526

### OpenSSL静态库编译

首先下载源码：[https://www.openssl.org/source/](https://www.openssl.org/source/)
在编译环境解压，进入openssl目录，给config加执行权限`chmod a+x config`, 之后执行`./config -fPIC no-shared`，表示静态编译，之后make即可，生成的libssl.a和libcrypto.a两个文件是我们需要的

引用时，将目录下include/openssl放到自己项目的include目录，两个库文件放到lib目录，Makefile中增加引用即可。
``` Makefile
INCLUDE += ******** -I./inc

LIB += ******* -L./lib -lssl -lcrypto
```

### Go拼接[]byte

``` go
  var buffer bytes.Buffer 
  buffer.Write(b1)
  buffer.Write(b2)
  b3 := buffer.Bytes()
  
  buffer.Reset()
  buffer.WriteString(str1)
  buffer.WriteString(str2)
  str3 := buffer.String()
```

使用buffer来拼接[]byte或者string都是可行且高效的

### Go实现Unix domain socket

``` go
/*server.go */

package main

import (
        "bufio"
        "fmt"
        "net"
        "time"
)

func main() {
        var unixAddr *net.UnixAddr
        unixAddr, _ = net.ResolveUnixAddr("unix", "/tmp/unix_sock")
        unixListener, _ := net.ListenUnix("unix", unixAddr)
        defer unixListener.Close()
        for {
                unixConn, err := unixListener.AcceptUnix()
                if err != nil {
                        continue
                }

                fmt.Println("A client connected : " + unixConn.RemoteAddr().String())
                go unixPipe(unixConn)
        }

}

func unixPipe(conn *net.UnixConn) {
        ipStr := conn.RemoteAddr().String()
        defer func() {
                fmt.Println("disconnected :" + ipStr)
                conn.Close()
        }()
        reader := bufio.NewReader(conn)

        for {
                message, err := reader.ReadString('\n')
                if err != nil {
                        return
                }

                fmt.Println(string(message))
                msg := time.Now().String() + "\n"
                b := []byte(msg)
                conn.Write(b)
        }
}

```

``` go
/* client.go */

package main

import (
        "bufio"
        "fmt"
        "net"
        "time"
)

var quitSemaphore chan bool

func main() {
        var unixAddr *net.UnixAddr
        unixAddr, _ = net.ResolveUnixAddr("unix", "/tmp/unix_sock")

        conn, _ := net.DialUnix("unix", nil, unixAddr)
        defer conn.Close()
        fmt.Println("connected!")

        go onMessageRecived(conn)

        b := []byte("time\n")
        conn.Write(b)

        <-quitSemaphore
}

func onMessageRecived(conn *net.UnixConn) {
        reader := bufio.NewReader(conn)
        for {
                msg, err := reader.ReadString('\n')
                fmt.Println(msg)
                if err != nil {
                        quitSemaphore <- true
                        break
                }
                time.Sleep(time.Second)
                b := []byte(msg)
                conn.Write(b)
        }
}
```

转载自：https://blog.51cto.com/4488415/2071335

### Go使用time.After实现超时机制

``` go 
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan string)
	go func() {
		// do something...
		ch <- "ok"
	}()

	select {
	case res := <-ch:
		fmt.Println(res)
	case <-time.After(time.Second * 1):
		fmt.Println("timeout")
	}
}

// select等待一个信号值，无论来自于哪个函数，都会向下继续执行。一般情况下，func()里面会用for循环保证持续运行，可以加一个timeout变量，在for中判断超时后退出，否则该routine会永远运行下去
```

### Shell中使用at命令实验后台延时任务

我们都知道Linux可以用at命令实现后台延时任务，但这个命令是交互式的，在Shell中我们可以这样来执行

``` bash
echo "iptables -D INPUT -s $ip -p tcp --dport $port -j ACCEPT" | at now 
+ 30 minutes
```

需要注意的是，at命令使用的是sh，需要考虑与默认shell的语法差异，命令执行后可以通过`at -c 命令号`来查看输入的命令是否是正确的。

### C、C++编译常见错误

`symbol lookup error xxxxx , undefined symbol`
这种情况一般是程序依赖的动态库不对，动态库中并没有程序所使用的符号，可以借助nm和ldd工具分析动态库

`libxxx.so: undefined reference to 'xxxxx'`
这种情况可能有多种原因：
1. 编译的时候动态、静态库没有引用好，导致找不到引用的函数体
2. 头文件中没有定义、导出函数，或者头文件没有正常加载导致找不到函数定义
3. 动态库编译时没有引用头文件导出函数主体，虽然动态库编译成功了，但是引用方找不到函数
4. C、C++混编,头文件引用、导出有误，详细如下

``` C
// 只要发生C和C++混编互相调用，就应该在头文件中加入如下定义
#ifdef __cplusplus    /*C++编译器包含的宏，例如用g++编译时，该宏就存在，则下面的语句extern "C"才会被执行*/
extern "C" {          /*C++编译器才能支持，C编译器不支持*/
#endif
 
extern int fun();
 
#ifdef __cplusplus
}
#endif

// 如果C库的头文件并没有做以上操作，可以在C++程序引用相关头文件时加入该定义
extern "C" {
include "xxxx.h"
}
```

### Grep、Sed等使用Basic正则如何匹配空格、括号

- 空格 直接使用 '\ '来匹配
- '[' ']' 使用'[[]' '[]]' 来匹配
